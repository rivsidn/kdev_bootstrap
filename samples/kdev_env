#!/bin/bash

export KDEV_KERNEL=arch/x86_64/boot/bzImage
export KDEV_DOCKER_IMAGE=ubuntu-16.04-amd64
export KDEV_QEMU_IMAGE=/opt/ubuntu-rootfs/ubuntu-16.04-amd64-rootfs.img

alias kdev_build='docker run -it --rm -v $PWD:/workspace -w /workspace --hostname kernel-dev $KDEV_DOCKER_IMAGE bash'

# 初始化桥接网络
kdev_init_bridge() {
	local bridge_name="${1:-br0}"
	local bridge_ip="${2:-172.20.0.1/24}"

	# 检查桥接是否存在
	if ! ip link show "$bridge_name" &>/dev/null; then
		echo "Creating bridge $bridge_name..."
		sudo ip link add "$bridge_name" type bridge
		sudo ip link set "$bridge_name" up
		sudo ip addr add "$bridge_ip" dev "$bridge_name"

		# 配置 NAT 让虚拟机能访问外网
		sudo iptables -t nat -A POSTROUTING -s "${bridge_ip%/*}" -j MASQUERADE
		sudo sysctl -w net.ipv4.ip_forward=1

		echo "Bridge $bridge_name created with IP $bridge_ip"
	else
		echo "Bridge $bridge_name already exists"
	fi
}

# 传输文件到 rootfs.img
kdev_push() {
	local src="$1"
	local dst="${2:-/root/}"

	# 检查参数
	if [ -z "$src" ]; then
		echo "Usage: kdev_push <source_file/dir> [destination_path]"
		echo "Example:"
		echo "  kdev_push module.ko          # 传输到 /root/"
		echo "  kdev_push *.ko /lib/modules/ # 传输多个文件"
		echo "  kdev_push mydir/ /opt/       # 传输目录"
		return 1
	fi

	# 检查源文件是否存在
	if [ ! -e "$src" ]; then
		echo "Error: Source '$src' not found"
		return 1
	fi

	# 检查镜像文件
	if [ ! -f "$KDEV_QEMU_IMAGE" ]; then
		echo "Error: QEMU image not found: $KDEV_QEMU_IMAGE"
		return 1
	fi

	# 创建临时挂载点
	local mount_point="/tmp/kdev-mount-$$"
	echo "Mounting $KDEV_QEMU_IMAGE..."

	# 挂载镜像
	sudo mkdir -p "$mount_point"
	if ! sudo mount -o loop "$KDEV_QEMU_IMAGE" "$mount_point"; then
		echo "Error: Failed to mount image"
		sudo rmdir "$mount_point"
		return 1
	fi

	# 检查目标目录是否存在
	if [ ! -d "$mount_point$dst" ]; then
		echo "Error: Target directory '$dst' does not exist in image"
		sudo umount "$mount_point"
		sudo rmdir "$mount_point"
		return 1
	fi

	# 复制文件
	echo "Copying $src to $dst..."
	if [ -d "$src" ]; then
		# 复制目录
		sudo cp -r "$src" "$mount_point$dst"
	else
		# 复制文件
		sudo cp "$src" "$mount_point$dst"
	fi

	local result=$?

	# 卸载镜像
	echo "Unmounting..."
	sudo umount "$mount_point"
	sudo rmdir "$mount_point"

	if [ $result -eq 0 ]; then
		echo "✓ File(s) transferred successfully"
	else
		echo "✗ Transfer failed"
		return 1
	fi
}

kdev_run() {
	local mode="$1"
	case "$mode" in
		terminal)
			qemu-system-x86_64 -kernel $KDEV_KERNEL -hda $KDEV_QEMU_IMAGE \
				-append "root=/dev/sda rw init=/bin/bash console=ttyS0" \
				-nographic -m 256M
			;;
		debug)
			qemu-system-x86_64 -kernel $KDEV_KERNEL -hda $KDEV_QEMU_IMAGE \
				-append "root=/dev/sda rw init=/bin/bash console=ttyS0" \
				-nographic -gdb tcp::1234 -S -m 256M
			;;
		internet)
			qemu-system-x86_64 -kernel $KDEV_KERNEL -hda $KDEV_QEMU_IMAGE \
				-netdev user,id=net0 -device e1000,netdev=net0 \
				-append "root=/dev/sda rw init=/sbin/init console=tty0" -m 256M
			;;
		bridge)
			# 桥接模式：最接近 Docker 的网络体验
			# 需要先创建桥接：
			# sudo ip link add br0 type bridge
			# sudo ip link set br0 up
			# sudo ip addr add 172.20.0.1/24 dev br0
			qemu-system-x86_64 -kernel $KDEV_KERNEL -hda $KDEV_QEMU_IMAGE \
				-netdev bridge,id=net0,br=br0 \
				-device e1000,netdev=net0 \
				-append "root=/dev/sda rw init=/sbin/init console=tty0" -m 512M
			;;
		*)
			echo "Usage: kdev_run {terminal|debug|internet|bridge}"
			echo "  terminal - 基础终端模式"
			echo "  debug    - GDB 调试模式"
			echo "  internet - 基础网络模式"
			echo "  bridge   - 桥接网络模式"
			;;
	esac
}

